<!DOCTYPE html>
<html>
<head>
    <title>Time Composer Sync Debug</title>
</head>
<body>
    <h1>Time Composer Sync Diagnostic</h1>
    <button onclick="testBackend()">Test Backend Connection</button>
    <button onclick="testIndexedDB()">Test IndexedDB</button>
    <button onclick="forcePull()">Force Pull from Backend</button>
    <button onclick="clearIndexedDB()">Clear IndexedDB</button>
    
    <div id="output" style="margin-top: 20px; font-family: monospace; white-space: pre-wrap;"></div>
    
    <script>
        const API_BASE = 'http://localhost:5001/api';
        let output = document.getElementById('output');
        
        function log(message) {
            output.textContent += new Date().toISOString() + ': ' + message + '\n';
        }
        
        async function testBackend() {
            log('Testing backend connection...');
            try {
                const response = await fetch(`${API_BASE}/entries`);
                if (response.ok) {
                    const data = await response.json();
                    log(`‚úÖ Backend connected successfully! Found ${data.length} entries`);
                } else {
                    log(`‚ùå Backend error: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Backend connection failed: ${error.message}`);
            }
        }
        
        async function testIndexedDB() {
            log('Testing IndexedDB...');
            try {
                const request = indexedDB.open('TimeComposerDB', 1);
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['entries'], 'readonly');
                    const store = transaction.objectStore('entries');
                    const getAllRequest = store.getAll();
                    
                    getAllRequest.onsuccess = () => {
                        const entries = getAllRequest.result;
                        log(`‚úÖ IndexedDB connected! Found ${entries.length} local entries`);
                    };
                };
                request.onerror = () => {
                    log(`‚ùå IndexedDB error: ${request.error}`);
                };
            } catch (error) {
                log(`‚ùå IndexedDB failed: ${error.message}`);
            }
        }
        
        async function forcePull() {
            log('Force pulling from backend...');
            try {
                const response = await fetch(`${API_BASE}/entries`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const serverEntries = await response.json();
                log(`üì• Fetched ${serverEntries.length} entries from backend`);
                
                // Open IndexedDB
                const request = indexedDB.open('TimeComposerDB', 1);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('entries')) {
                        const store = db.createObjectStore('entries', { 
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        store.createIndex('created_at', 'created_at', { unique: false });
                        store.createIndex('status', 'status', { unique: false });
                        store.createIndex('sync_status', 'sync_status', { unique: false });
                        store.createIndex('client_code', 'client_code', { unique: false });
                        log('üìÑ Created IndexedDB structure');
                    }
                };
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['entries'], 'readwrite');
                    const store = transaction.objectStore('entries');
                    
                    // Clear existing entries
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => {
                        log('üóëÔ∏è Cleared existing IndexedDB entries');
                        
                        // Add server entries
                        let count = 0;
                        serverEntries.forEach(entry => {
                            const addRequest = store.put({...entry, sync_status: 'synced'});
                            addRequest.onsuccess = () => {
                                count++;
                                if (count === serverEntries.length) {
                                    log(`‚úÖ Successfully imported ${count} entries to IndexedDB`);
                                    log('üîÑ Please refresh the main page to see the data');
                                    log('   URL: http://localhost:8080');
                                }
                            };
                        });
                    };
                    
                    transaction.onerror = (e) => {
                        log(`‚ùå Transaction error: ${e.target.error}`);
                    };
                };
                
                request.onerror = () => {
                    log(`‚ùå IndexedDB error: ${request.error}`);
                };
            } catch (error) {
                log(`‚ùå Force pull failed: ${error.message}`);
            }
        }
        
        async function clearIndexedDB() {
            log('Clearing IndexedDB...');
            try {
                const deleteRequest = indexedDB.deleteDatabase('TimeComposerDB');
                deleteRequest.onsuccess = () => {
                    log('‚úÖ IndexedDB cleared successfully');
                    log('Please refresh the main page to reinitialize');
                };
                deleteRequest.onerror = () => {
                    log(`‚ùå Failed to clear IndexedDB: ${deleteRequest.error}`);
                };
            } catch (error) {
                log(`‚ùå Clear failed: ${error.message}`);
            }
        }
    </script>
</body>
</html>